/*
 *  main.cpp
 *  
 *
 *  Created by Panagiotis Chatzidoukas on 3/28/13.
 *  Copyright 2013 ETH Zurich. All rights reserved.
 *
 */

#include <iostream>
#include <string>
#include <sstream>
#include <mpi.h>
#include <hdf5.h>
#include <omp.h>
#define _TRANSPOSE_DATA_
#define _COLLECTIVE_IO_

#include "ArgumentParser.h"
#include "Reader_WaveletCompression.h"

int main(int argc, const char **argv)
{
	const double init_t0 = omp_get_wtime();

	/* Initialize MPI */
	MPI::Init_thread(MPI_THREAD_SERIALIZED);

	/* MPI variables */
	MPI_Comm comm  = MPI_COMM_WORLD;
	MPI_Info info  = MPI_INFO_NULL;
	MPI::Intracomm& mycomm = MPI::COMM_WORLD;

	const int mpi_rank = mycomm.Get_rank();
	const int mpi_size = mycomm.Get_size();

	const bool isroot = !mpi_rank;

	ArgumentParser argparser(argc, argv);

	if (isroot)
		argparser.loud();
	else
		argparser.mute();

	const string inputfile_name = argparser("-simdata").asString("none");

	if ((inputfile_name == "none"))
	{
		printf("usage: %s -simdata <filename> [-verb <0|1|2|3>]\n", argv[0]);
		exit(1);
	}

	const int verbose = argparser("-verb").asInt(0);

#if 1
	Reader_WaveletCompressionMPI myreader(mycomm, inputfile_name);
#else
	Reader_WaveletCompression myreader(inputfile_name);
#endif
	myreader.load_file();
	const double init_t1 = omp_get_wtime();

	const double t0 = omp_get_wtime(); 

//	int dim[3], period[3], reorder;
//	int coord[3], id;

	int NBX = myreader.xblocks();
	int NBY = myreader.yblocks();
	int NBZ = myreader.zblocks();

	if ((!mpi_rank) || (verbose == 1))
		fprintf(stdout, "I found in total %dx%dx%d blocks.\n", NBX, NBY, NBZ);

	int StartX, StartY, StartZ;
	int EndX, EndY, EndZ;
	
	StartX = NBX;
	EndX = -1;

	StartY = NBY;
	EndY = -1;
	
	StartZ = NBZ;
	EndZ = -1;
	
	int set_counter = 0;

	if (verbose == 1)
		fprintf(stdout, "Initial ROI = [%d,%d]x[%d,%d]x[%d,%d]\n", StartX, EndX, StartY, EndY, StartZ, EndZ);	
		
	int NX = (EndX-StartX+1)*_BLOCKSIZE_;
	int NY = (EndY-StartY+1)*_BLOCKSIZE_;
	int NZ = (EndZ-StartZ+1)*_BLOCKSIZE_;

	static Real targetdata[_BLOCKSIZE_][_BLOCKSIZE_][_BLOCKSIZE_];
	
	const int nblocks = NBX*NBY*NBZ;
	const int b_end = ((nblocks + (mpi_size - 1))/ mpi_size) * mpi_size; 

	for (int b = mpi_rank; b < b_end; b += mpi_size)	
	{
#if defined(_TRANSPOSE_DATA_)
		int x = b / (NBY * NBZ);
		int y = (b / NBZ) % NBY;
		int z = b % NBZ;
#else
		int z = b / (NBY * NBX);
		int y = (b / NBX) % NBY;
		int x = b % NBX;
#endif

#if 0
		int skip_me;
		if (set_counter > 0)
		{
			if ((StartX <= x) && (x <= EndX) && (StartY <= y) && (y <= EndY) && (StartZ <= z) && (z <= EndZ))
				skip_me = 1;
			else
				skip_me = 0;
		}
		if (skip_me) continue;
#endif

		if ((b < nblocks))
		{
			if (verbose == 2)
				fprintf(stdout, "loading block( %d, %d, %d )...\n", x, y, z); 

			double zratio = myreader.load_block2(x, y, z, targetdata);
			
			Real bmin = targetdata[0][0][0];
			Real bmax = targetdata[0][0][0];
			
			for (int zb = 0; zb < _BLOCKSIZE_; zb++)
			{
				for (int yb = 0; yb < _BLOCKSIZE_; yb++)
					for (int xb = 0; xb < _BLOCKSIZE_; xb++)
					{
						Real d = targetdata[zb][yb][xb];
						if (d > bmax) {
							bmax = d;
						}
						if (d < bmin) {
							bmin = d;
						}
					}
			}

			if (verbose == 3)
				fprintf(stdout, "%.3lf bmin = %.3lf bmax = %.3lf\n", zratio, bmin, bmax);
				
			if (bmin < bmax)	// !=
			{
				if (set_counter == 0)
				{
					StartX = EndX = x;
					StartY = EndY = y;
					StartZ = EndZ = z;					
					set_counter++;
				}
				else
				{
					if (x < StartX) StartX = x;
					if (x > EndX)	EndX = x;
					if (y < StartY) StartY = y;
					if (y > EndY)	EndY = y;
					if (z < StartZ) StartZ = z;
					if (z > EndZ)	EndZ = z;
				}
			}

		}
		else {
			//fprintf(stdout, "empty blockk( %d, %d, %d )...\n", x, y, z); 
		}
	}

	MPI_Barrier(MPI_COMM_WORLD);
	const double t1 = omp_get_wtime(); 

	if (verbose == 1)
		fprintf(stdout, "Local ROI = [%d,%d]x[%d,%d]x[%d,%d]\n", StartX, EndX, StartY, EndY, StartZ, EndZ);	fflush(0);
	MPI_Barrier(MPI_COMM_WORLD);

	int gStartX, gStartY, gStartZ;
	int gEndX, gEndY, gEndZ;
	

	MPI_Reduce(&StartX, &gStartX, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);
	MPI_Reduce(&EndX, &gEndX, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);
	MPI_Reduce(&StartY, &gStartY, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);
	MPI_Reduce(&EndY, &gEndY, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);
	MPI_Reduce(&StartZ, &gStartZ, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);
	MPI_Reduce(&EndZ, &gEndZ, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);

	if (!mpi_rank)
	{
		fprintf(stdout, "Final ROI = [%d,%d]x[%d,%d]x[%d,%d]\n", gStartX, gEndX, gStartY, gEndY, gStartZ, gEndZ);	
		fprintf(stdout, "Init time = %.3lf seconds\n", init_t1-init_t0);
		fprintf(stdout, "Elapsed time = %.3lf seconds\n", t1-t0);
		fflush(0);
	}
		
	MPI::Finalize();

	return 0;
}
